<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../nebula-element-mixin/nebula-element-mixin.html">

<script>
(function() {
  'use strict'

  // symbols for private members
  const computeLang = Symbol()

  // symbols for protected members
  const compute = Symbol.for('Nebula.ElementMixin.compute')

  /**
   * Determine the preferred application language based on browser support.
   */
  class NebulaLanguage extends Nebula.ElementMixin(Polymer.Element) {

    /**
     * Gets the custom element name.
     * @type {string}
     */
    static get is() { return 'nebula-language' }

    /**
     * Gets the property definitions for data binding.
     * @type {Object}
     * @property {Array} supported - The set of languages supported by the application.
     * @property {string} lang - The preferred language supported by the application and the browser.
     */
    static get properties() {
      return {
        supported: {
          type: Array
        },
        lang: {
          type: String,
          readOnly: true,
          notify: true
        }        
      }
    }

    /**
     * Lifecycle callback invoked when a new element instance is created.
     */
    constructor() {
      super()
      this[compute]('lang', 'supported', this[computeLang])
    }

    /**
     * Lifecycle callback invoked when element has been initialized.
     */
    ready() {
      super.ready();
      this.setAttribute('hidden', '')
    }

    /**
     * Computed property handler to match the set of application supported languages with languages supported by the browser, and select the preferred application language.
     * @param {Array} supported - The set of languages supported by the application.
     * @private
     */
    [computeLang](supported) {
      if (!(supported && supported.length > 0)) return

      // get the supported browser languages
      const browserLang = navigator.language || navigator.browserLanguage || navigator.userLanguage || navigator.systemLanguage || supported[0]
      const browserLangs = (navigator.languages && navigator.languages.length > 0) ? navigator.languages : [browserLang]

      // convert languages into set for uniqueness and convert to lowercase
      // if language is multi-part, add the base language code as fallback
      const browserSet = new Set()
      for (let i = 0; i < browserLangs.length; i++) {
        const lang = browserLangs[i].toLowerCase()
        browserSet.add(lang)

        if (lang.indexOf('-') !== -1) {
          const baseLang = lang.substring(0, lang.indexOf('-'))
          browserSet.add(baseLang)
        }         
      }

      // convert supported languages into set for uniqueness and convert to lowercase
      const supportedSet = new Set()
      for (let i = 0; i < supported.length; i++) {
        const lang = supported[i].toLowerCase()
        supportedSet.add(lang)
      }      

      // iterate over browsers set (since this is the user preferred order)
      // if supported has language then return first found as preferred
      for (let lang of browserSet) {
        if (supportedSet.has(lang)) return lang
      }
    }
  }

  customElements.define(NebulaLanguage.is, NebulaLanguage)
}())
</script>
